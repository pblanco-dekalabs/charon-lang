;;;
; MIT License
;
; Copyright (c) 2020 Pablo Blanco CeldrÃ¡n
;
; Permission is hereby granted, free of charge, to any person obtaining a copy
; of this software and associated documentation files (the "Software"), to deal
; in the Software without restriction, including without limitation the rights
; to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
; copies of the Software, and to permit persons to whom the Software is
; furnished to do so, subject to the following conditions:
;
; The above copyright notice and this permission notice shall be included in all
; copies or substantial portions of the Software.
;
; THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
; IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
; FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
; AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
; LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
; OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
; SOFTWARE.
;;;

; Example of import:
(import lib :from "samples/lib")
; Import can be destructured if using a binding vector.
(import [ sum ] :from "samples/lib")

; Compose functions (Not the same as thread-thru!)
(let [a (fn [x] (* x 2))
      b (fn [x] (+ x 5))]
  (def-value ab
    (>>= a b)))
(println! "(b (a 3)) = " (ab 3))

(println! "Hello world!")
(println! "oh-man ->" (object/get "oh-man" lib))
(println! "(sum 2 2) ->" (sum 2 2))

; Simple matching:
(let [val :b]
  (println! "when " val " = "
    (when val
      :a "Is A!"
      :b "Is B!"
      :c "Is C!"
      #  "Unexpected case.")))

; For loop, for side-effects (Sometimes you need 'em).
; Numeric for like this one is optimized away as a normal for
(for [i (range 0 10)]
  (println! (str "i = " i)))

; Other sources of iterable components are transformed to pairs:
(for [v [1 2 3 4]]
  (println! (str "v = " v)))

; If you put two names, the for will always run in pairs:
; Being the second the "index" or the "key" depending on what you're iterating.
(for [v i (range 10 20)]
  (println! (str i " = " v)))

; For security reasons, externs are considered impure.
(def-extern myFunc)

; Impure functions:
(let [state (atom 0)]
  (def-impure print-state []
    (println! "State: " (atom/get state)))
  (def-impure count []
    (atom/reset! state
      (+ (atom/get state) 1))))

(print-state)
(count)
(print-state)
(count)
(print-state)

(let [file (file/open "samples/meta.lua" "w")]
  (if (some? file)
    (do
      (file/write file "print('Hello there!')")
      (file/close file))
    (println! "Could not open file for writing!")))

(def-value tester true)
(if tester
  (+ 2 2)
  (println! "nooo")
  (- 1 1))

(if (= tester true)
  (println! "Simple dimple"))

; Comparison operators
(def-value simple-eq (= 1 2))
(def-value complex-eq (= 1 2 3 4))
(def-value complex-lt (> 1 2 3 4))
(def-value complex-gt (< 1 2 3 4))
(def-value complex-gteq (>= 1 2 3 4))

; Logic operators
(def-value all-or (or true false false true))
(def-value all-and (and true false false true))
; "not" has 1-arity, so the excess of arguments produces error.
(def-value simple-not (not true))
; Other stuff
(def-value more-things
  { :nor (nor true false true)
    :nand (nand true false true)
    :xor (xor true false) ; Plain old XOR
    :xor-nary (xor true false true false true false) ; Xor is n-ary in fact.
  })
(println! "nor =" (:nor more-things)) ; Shorthand!
(println! "nand =" (table/get :nand more-things)) ; Same thing!
(println! "xor =" (:xor more-things))
(println! "xor-nary =" (:xor-nary more-things))

(def double [x]
  (* x 2))

; Vectors
(def-value doubles
  (vector/map [1 2 3 4] double))

(def-value triples
  (vector/map [1 2 3 4]
    (fn [x]
      (* x 3))))

(if tester
  (+ 2 3)
  (* 5 5))

; Do blocks!
(if tester
  (do
    (println! "Thing one")
    (println! "Thing two..."))
  (println! "This is part of the 'else'"))

(def something [] unit)

; Somewhat threading macros
(println! "Result:"
  (-> 2
    (+ 4)
    (* 8)))

(<- 2
  (+ 4)
  (* 8)
  (println! "Result:"))

; Try catch!
(try (something)
  (catch [err]
    (println! "Error! " err)))

; For sake of optimization, instead of reducing functions, arithmetics are
; expanded to their binary operator counterparts.
(println! "Arithmetic expansion! "
  (+ (- 2 5 6) 1 2 3 4 5 (* 1 2 6 8)))
