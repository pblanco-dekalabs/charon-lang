; Example of import:
(import "samples/lib" lib)

(println "Hello world!")
(println "oh-man ->" (get "oh-man" lib))
(println "(sum 2 2) ->" (call (get "sum" lib) 2 2))

; That's it folks!
; Impure functions tho:

(let [state (atom 0)]
  (def-impure print-state []
    (println "State: " (atom/get state)))
  (def-impure count []
    (atom/set! state
      (+ (atom/get state) 1))))

; An impure main!
(def-impure impure-main []
  (let [file (file/open "test.txt" "r")]
    (if (some? file)
      (do
        (file/write file "Hello there!")
        (file/close file))))
  (print-state)
  (count)
  (print-state)
  (count)
  (print-state))

(def-value tester true)
(if tester
  (+ 2 2)
  (println "nooo")
  (- 1 1))

(if (= tester true)
  (println "Simple dimple"))

(def-value complex-eq (= 1 2 3 4))

(if tester
  (+ 2 3)
  (* 5 5))

; Do blocks!
(if tester
  (do
    (println "Thing one")
    (println "Thing two..."))
  (println "This is part of the 'else'"))

(def something [] unit)

; Try catch!
(try (something)
  (catch [err]
    (println "Error! " err)))

; For sake of optimization, instead of reducing functions, arithmetics are
; expanded to their binary operator counterparts.
(println "Arithmetic expansion! "
  (+ (- 2 5 6) 1 2 3 4 5 (* 1 2 6 8)))

; Main must be pure!
; Opaque call allows calling impure functions from pure context.
(def main []
  (opaque-call impure-main))